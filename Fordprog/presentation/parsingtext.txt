Parsing is the process of determining how a string of terminals can be generated 
by a grammar. In discussing this problem, it is helpful to think of a parse tree
being constructed, even though a compiler may not construct one, in practice.
However, a parser must be capable of constructing the tree in principle, or else
the translation cannot be guaranteed correc
2.4. PARSING 61This section introduces a parsing method called \recursive descent," whichcan be used both to parse and to implement syntax-directed translators. A complete Java program, implementing the translation scheme of Fig. 2.15, appears
in the next section. A viable alternative is to use a software tool to generate
a translator directly from a translation scheme. Section 4.9 describes such atool | Yacc; it can implement the translation scheme of Fig. 2.15 without
modication.
For any context-free grammar there is a parser that takes at most O(n3
)
time to parse a string of n terminals. But cubic time is generally too expensive. Fortunately, for real programming languages, we can generally design agrammar that can be parsed quickly. Linear-time algorithms suce to parse
essentially all languages that arise in practice. Programming-language parsers
almost always make a single left-to-right scan over the input, looking ahead one
terminal at a time, and constructing pieces of the parse tree as they go.
Most parsing methods fall into one of two classes, called the top-down andbottom-up methods. These terms refer to the order in which nodes in the parse
tree are constructed. In top-down parsers, construction starts at the root andproceeds towards the leaves, while in bottom-up parsers, construction starts at
the leaves and proceeds towards the root. The popularity of top-down parsers
is due to the fact that ecient parsers can be constructed more easily by handusing top-down methods. Bottom-up parsing, however, can handle a larger class
of grammars and translation schemes, so software tools for generating parsers
directly from grammars often use bottom-up methods.
2.4.1 Top-Down Parsing
We introduce top-down parsing by considering a grammar that is well-suitedfor this class of methods. Later in this section, we consider the constructionof top-down parsers in general. The grammar in Fig. 2.16 generates a subset
of the statements of C or Java. We use the boldface terminals if and for for
the keywords \if" and \for", respectively, to emphasize that these character
sequences are treated as units, i.e., as single terminal symbols. Further, the
terminal expr represents expressions; a more complete grammar would use anonterminal expr and have productions for nonterminal expr. Similarly, other
is a terminal representing other statement constructs.
The top-down construction of a parse tree like the one in Fig. 2.17, is done
by starting with the root, labeled with the starting nonterminal stmt, and repeatedly performing the following two steps.
1. At node N, labeled with nonterminal A, select one of the productions for
A and construct children at N for the symbols in the production body. 2. Find the next node at which a subtree is to be constructed, typically the
leftmost unexpanded nonterminal of the tree.
For some grammars, the above steps can be implemented during a single
left-to-right scan of the input string. The current terminal being scanned in the
62 CHAPTER 2. A SIMPLE SYNTAX-DIRECTED TRANSLATORstmt ! expr ;
j if ( expr ) stmt
j for ( optexpr ; optexpr ; optexpr ) stmt
j other
optexpr ! 
j expr
Figure 2.16: A grammar for some statements in C and Java
other
) stmt
expr
; optexpr
expr
stmt
; optexpr

for ( optexpr
Figure 2.17: A parse tree according to the grammar in Fig. 2.16
input is frequently referred to as the lookahead symbol. Initially, the lookaheadsymbol is the rst, i.e., leftmost, terminal of the input string. Figure 2.18illustrates the construction of the parse tree in Fig. 2.17 for the input string
for ( ; expr ; expr ) other
Initially, the terminal for is the lookahead symbol, and the known part of the
parse tree consists of the root, labeled with the starting nonterminal stmt inFig. 2.18(a). The ob jective is to construct the remainder of the parse tree insuchaway that the string generated by the parse tree matches the input string.
For a match to occur, the nonterminal stmt in Fig. 2.18(a) must derive astring that starts with the lookahead symbol for. In the grammar of Fig. 2.16,
there is just one production for stmt that can derive such a string, so we select it,
and construct the children of the root labeled with the symbols in the productionbody. This expansion of the parse tree is shown in Fig. 2.18(b).
Each of the three snapshots in Fig. 2.18 has arrows marking the lookaheadsymbol in the input and the node in the parse tree that is being considered.
Once children are constructed at a node, we next consider the leftmost child. InFig. 2.18(b), children have just been constructed at the root, and the leftmost
child labeled with for is being considered.
When the node being considered in the parse tree is for a terminal, andthe terminal matches the lookahead symbol, then we advance in both the parse
tree and the input. The next terminal in the input becomes the new lookaheadsymbol, and the next child in the parse tree is considered. In Fig. 2.18(c), the
arrow in the parse tree has advanced to the next child of the root, and the arrow
2.4. PARSING 63INPUT for ( ; expr ;
(a)
TREE
stmt
INPUT for ( ; expr ; expr ) other
(c)
TREE
PARSE
INPUT for ( ; expr ; expr ) other
(b)
TREE
PARSE
expr ) other
PARSE
; optexpr ) stmt
stmt
optexpr
for ( optexpr ; optexpr ; optexpr )
stmt
stmt
for ( optexpr ;
Figure 2.18: Top-down parsing while scanning the input from left to right
in the input has advanced to the next terminal, which is (. A further advance
will take the arrow in the parse tree to the child labeled with nonterminal
optexpr and take the arrow in the input to the terminal ;. At the nonterminal node labeled optexpr, we repeat the process of selecting aproduction for a nonterminal. Productions with  as the body (\-productions")
require special treatment. For the moment, we use them as a default whenno other production can be used; we return to them in Section 2.4.3. Withnonterminal optexpr and lookahead ;, the -production is used, since ; does
not match the only other production for optexpr, which has terminal expr as
its body. In general, the selection of a production for a nonterminal may involve trialand-error; that is, we may have to try a production and backtrack to try another
production if the rst is found to be unsuitable. A production is unsuitable
if, after using the production, we cannot complete the tree to match the input
64 CHAPTER 2. A SIMPLE SYNTAX-DIRECTED TRANSLATORstring. Backtracking is not needed, however, in an important special case calledpredictive parsing, which we discuss next.
2.4.2 Predictive Parsing
Recursive-descent parsing is a top-down method of syntax analysis in whicha set of recursive procedures is used to process the input. One procedure is
associated with each nonterminal of a grammar. Here, we consider a simple formof recursive-descent parsing, called predictive parsing, in which the lookaheadsymbol unambiguously determines the 
ow of control through the procedure
body for each nonterminal. The sequence of procedure calls during the analysis
of an input string implicitly denes a parse tree for the input, and can be usedto build an explicit parse tree, if desired.
The predictive parser in Fig. 2.19 consists of procedures for the nonterminals stmt and optexpr of the grammar in Fig. 2.16 and an additional procedure
match, used to simplify the code for stmt and optexpr. Procedure match(t) compares its argument t with the lookahead symbol and advances to the next input
terminal if they match. Thus match changes the value of variable lookahead, aglobal variable that holds the currently scanned input terminal.
Parsing begins with a call of the procedure for the starting nonterminal stmt. With the same input as in Fig. 2.18, lookahead is initially the rst terminal for. Procedure stmt executes code corresponding to the production
stmt ! for ( optexpr ; optexpr ; optexpr ) stmt
In the code for the production body | that is, the for case of procedure stmt |each terminal is matched with the lookahead symbol, and each nonterminal
leads to a call of its procedure, in the following sequence of calls:
match(for); match(
0(0);
optexpr (); match(
0;0); optexpr (); match(
0;0); optexpr ();
match(
0)0); stmt ();
Predictive parsing relies on information about the rst symbols that can be
generated by a production body. More precisely, let  be a string of grammar
symbols (terminals and/or nonterminals). We dene FIRST() to be the set of
terminals that appear as the rst symbols of one or more strings of terminals
generated from . If  is  or can generate , then  is also in FIRST().
The details of how one computes FIRST() are in Section 4.4.2. Here, we
shall just use ad hoc reasoning to deduce the symbols in FIRST(); typically, will either begin with a terminal, which is therefore the only symbol in FIRST(),
or  will begin with a nonterminal whose production bodies begin with terminals, in which case these terminals are the only members of FIRST().
For example, with respect to the grammar of Fig. 2.16, the following are
correct calculations of FIRST.
2.4. PARSING 65void stmt () f
switch ( lookahead ) f
case expr: match(expr); match(
0;0); break;
case if:match(if); match(
0(0); match(expr); match(
0)0); stmt ();
break;
case for: match(for); match(
0(0);
optexpr (); match(
0;0); optexpr (); match(
0;0); optexpr ();
match(
0)0); stmt (); break;
case other;
match(other); break;
default:
report ("syntax error");
g
g
void optexpr () f
if ( lookahead == expr ) match(expr);
g
void match(terminal t) f
if ( lookahead == t ) lookahead = nextTerminal;
else report ("syntax error");
g
Figure 2.19: Pseudocode for a predictive parser
FIRST(stmt) = fexpr; if; for; otherg
FIRST(expr ;) = fexprg
The FIRST sets must be considered if there are two productions A ! andA ! . Ignoring -productions for the moment, predictive parsing requires
FIRST() and FIRST() to be disjoint. The lookahead symbol can then be usedto decide which production to use; if the lookahead symbol is in FIRST(), then is used. Otherwise, if the lookahead symbol is in FIRST(), then  is used.
2.4.3 When to Use -Productions
Our predictive parser uses an -production as a default when no other production can be used. With the input of Fig. 2.18, after the terminals for and ( are
matched, the lookahead symbol is ;. At this point procedure optexpr is called,
and the code
66 CHAPTER 2. A SIMPLE SYNTAX-DIRECTED TRANSLATORif ( lookahead == expr ) match(expr);
in its body is executed. Nonterminal optexpr has two productions, with bodies
expr and . The lookahead symbol \;" does not match the terminal expr, sothe production with body expr cannot apply. In fact, the procedure returns
without changing the lookahead symbol or doing anything else. Doing nothingcorresponds to applying an -production.
More generally, consider a variant of the productions in Fig. 2.16 where
optexpr generates an expression nonterminal instead of the terminal expr:
optexpr ! expr
j  Thus, optexpr either generates an expression using nonterminal expr or it generates . While parsing optexpr, if the lookahead symbol is not in FIRST(expr),
then the -production is used.
For more on when to use -productions, see the discussion of LL(1) grammars
in Section 4.4.3.
2.4.4 Designing a Predictive Parser
We can generalize the technique introduced informally in Section 2.4.2, to applyto any grammar that has disjoint FIRST sets for the production bodies belongingto any nonterminal. We shall also see that when we have a translation scheme |that is, a grammar with embedded actions | it is possible to execute those
actions as part of the procedures designed for the parser.
Recall that a predictive parser is a program consisting of a procedure for
every nonterminal. The procedure for nonterminal A does two things.
1. It decides which A-production to use by examining the lookahead symbol.
The production with body  (where  is not , the empty string) is usedif the lookahead symbol is in FIRST(). If there is a con
ict betweentwo nonempty bodies for any lookahead symbol, then we cannot use this
parsing method on this grammar. In addition, the -production for A, if
it exists, is used if the lookahead symbol is not in the FIRST set for anyother production body for A.
2. The procedure then mimics the body of the chosen production. That
is, the symbols of the body are \executed" in turn, from the left. Anonterminal is \executed" by a call to the procedure for that nonterminal,
and a terminal matching the lookahead symbol is \executed" by readingthe next input symbol. If at some point the terminal in the body does
not match the lookahead symbol, a syntax error is reported.
Figure 2.19 is the result of applying these rules to the grammar in Fig. 2.16.
2.4. PARSING 67Just as a translation scheme is formed by extending a grammar, a syntaxdirected translator can be formed by extending a predictive parser. An algorithm for this purpose is given in Section 5.4. The following limited constructionsuces for the present:
1. Construct a predictive parser, ignoring the actions in productions.
2. Copy the actions from the translation scheme into the parser. If an actionappears after grammar symbol X in production p, then it is copied after
the implementation of X in the code for p. Otherwise, if it appears at the
beginning of the production, then it is copied just before the code for the
production body. We shall construct such a translator in Section 2.5.
2.4.5 Left Recursion
It is possible for a recursive-descent parser to loop forever. A problem arises
with \left-recursive" productions like
expr ! expr + term
where the leftmost symbol of the body is the same as the nonterminal at the
head of the production. Suppose the procedure for expr decides to apply this
production. The body begins with expr so the procedure for expr is calledrecursively. Since the lookahead symbol changes only when a terminal in the
body is matched, no change to the input took place between recursive calls of
expr. As a result, the second call to expr does exactly what the rst call did,
which means a third call to expr, and so on, forever.
A left-recursive production can be eliminated by rewriting the oendingproduction. Consider a nonterminal A with two productions
A ! A j 
where  and  are sequences of terminals and nonterminals that do not start
with A. For example, in
expr ! expr + term j term
nonterminal A = expr, string  = + term, and string  = term. The nonterminal A and its production are said to be left recursive, because
the production A ! A has A itself as the leftmost symbol on the right side.4
Repeated application of this production builds up a sequence of 's to the right
of A, as in Fig. 2.20(a). When A is nally replaced by , we have a  followedby a sequence of zero or more 's.
The same eect can be achieved, as in Fig. 2.20(b), by rewriting the productions for A in the following manner, using a new nonterminal R: 4
In a general left-recursive grammar, instead of a production A ! A, the nonterminal Amay derive A through intermediate productions.
R ! R j  Nonterminal R and its production R ! R are right recursive because this production for R has R itself as the last symbol on the right side. Right-recursive
productions lead to trees that grow down towards the right, as in Fig. 2.20(b).
Trees growing down to the right make it harder to translate expressions containing left-associative operators, such as minus. In Section 2.5.2, however, we
shall see that the proper translation of expressions into postx notation canstill be attained by a careful design of the translation scheme.
In Section 4.3.3, we shall consider more general forms of left recursion andshow how all left recursion can be eliminated from a grammar.
